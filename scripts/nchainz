#!/bin/bash
# nchainz - start an arbitrary number of chains and relayers

progname=$(basename -- "$0")
thisdir=$(dirname -- ${BASH_SOURCE[0]})

trap 'kill $(jobs -p) 2>/dev/null' EXIT 

BASEDIR=$progname
DEFAULT_CONFIG=gaia

RELAYER_DIR=$(cd "$thisdir/.." && pwd)
CONFIGS_DIR="$RELAYER_DIR/configs"

CHAIN_RE='^([^=]+)=(.+)$'
LINK_RE='^([^:]+):([^:]+)$'

CHAINS=()
LINKS=()

# Ensure jq is installed
if [[ ! -x "$(which jq)" ]]; then
  echo "jq (a tool for parsing json in the command line) is required..."
  echo "https://stedolan.github.io/jq/download/"
  exit 1
fi

nextID=0
generate_id() {
  config=$1
  while true; do
    id="ibc$nextID"
    found=no
    for chain in ${CHAINS[@]}; do
      case $chain in
      "$id="*)
        found=yes
        break
      esac
    done
    if [[ $found != yes ]]; then
      return
    fi
    nextID=$(( $nextID + 1 ))
  done
}

IDS=()
CONFIGS=()
JSONS=()
SRCS=()
DSTS=()

get_alpha() {
  id="$1"
  ida=$(echo "$1" | sed -e 's/0/zero/g; s/1/one/g; s/2/two/g; s/3/three/g; s/4/four/g; s/5/five/g; s/6/six/g; s/7/seven/g; s/8/eight/g; s/9/nine/g;')
}

get_port() {
  id="$1"
  for i in ${!IDS[@]}; do
    if [[ ${IDS[$i]} == $id ]]; then
      port=$(eval echo $(jq '."port-id"' ${JSONS[$i]}))
      return
    fi
  done
  echo "$progname: cannot locate \`$id' in chain ids list"
  exit 1
}

validate() {
  status=0
  # Have at least one default.
  if [[ ${#CHAINS[@]} -eq 0 ]]; then
    generate_id "$DEFAULT_CONFIG"
    CHAINS+=( "$id=$DEFAULT_CONFIG" )
  fi

  for chain in ${CHAINS[@]} LAST_CHAIN; do
    if [[ $chain == LAST_CHAIN ]]; then
      if [[ ${#CHAINS[@]} -ge 2 ]]; then
        # Don't need more config
        break
      fi
      # We need at least two chains, so use the same config.
      config=${CONFIGS[0]}
      generate_id "$config"
      chain="$id=$config"
      CHAINS+=( "$chain" )
    fi
    if [[ $chain =~ $CHAIN_RE ]]; then
      id=${BASH_REMATCH[1]}
      config=${BASH_REMATCH[2]}
      IDS+=( "$id" )
      json=$CONFIGS_DIR/$config.json
      if [[ ! -f $json ]]; then
        echo 1>&2 "$progname: error: CHAIN \`$chain' config \`$json' does not exist"
        status=1
      fi
      CONFIGS+=( "$config" )
      JSONS+=( "$json" )
    else
      echo 1>&2 "$progname: error: invalid CHAIN specification \`$chain'"
      status=1
    fi
  done

  # Default links as a circuit around the chains.
  if [[ ${#LINKS[@]} -eq 0 ]]; then
    prior=
    for id in ${IDS[@]}; do
      if [[ -n $prior ]]; then
        LINKS+=( "$prior:$id" )
      fi
      prior=$id
    done
    if [[ -z $prior ]]; then
      echo 1>&2 "$progname: error: no configured LINKS"
      status=1
    elif [[ $prior != ${IDS[1]} ]]; then
      LINKS+=( "$prior:${IDS[0]}" )
    fi
  fi

  for link in ${LINKS[@]}; do
    if [[ $link =~ $LINK_RE ]]; then
      src=${BASH_REMATCH[1]}
      dst=${BASH_REMATCH[2]}
      found_src=no
      found_dst=no
      for id in ${IDS[@]}; do
        [[ $id == $src ]] && found_src=yes
        [[ $id == $dst ]] && found_dst=yes
      done
      if [[ $found_src != yes ]]; then
        echo 1>&2 "$progname: error: LINK \`$link' source ID \`$src' does not match a CHAIN"
        status=1
      fi
      if [[ $found_dst != yes ]]; then
        echo 1>&2 "$progname: error: LINK \`$link' destination ID \`$dst' does not match a CHAIN"
        status=1
      fi
      SRCS+=( "$src" )
      DSTS+=( "$dst" )
    else
      echo 1>&2 "$progname: error: invalid LINK specification \`$link'"
      status=1
    fi
  done
  [[ $status -eq 0 ]] || usage $status
}

show_plan() {
  echo "Here's the plan:"
  for i in ${!IDS[@]}; do
    id=${IDS[$i]}
    json=${JSONS[$i]}
    echo " create $id from $json"
  done
  for i in ${!SRCS[@]}; do
    src=${SRCS[$i]}
    dst=${DSTS[$i]}
    echo " link $src to $dst"
  done
}

usage() {
  status=$1
  if [[ $status -eq 0 ]]; then
    cat <<EOF
Usage: $progname [CONFIG|CHAIN|LINK]...

Create a configuration for running IBC chains and relayer links.

Options:
  --basedir=DIR  create DIR [default=\`$progname']
  --help         display this help

CONFIGs are found in \`$CONFIGS_DIR/CONFIG`.
If no arguments are supplied, use \`$DEFAULT_CONFIGS`.

Create configuration in \`$DATA' for:
 each CHAIN, which is \`ID=CONFIG'
 each LINK, which is \`SRCID:DSTID'
 
If no LINKS are supplied, use a circuit around the CHAINS.
EOF
  else
    echo "Try \`$progname --help' for more information"
  fi
  exit $status
}

args=${1+"$@"}
while [[ $# -gt 0 ]]; do
  case "$1" in
  --help)
    usage 0
    ;;
  --basedir=*)
    BASEDIR=$(echo "$1" | sed -e 's/^[^=]*//')
    ;;
  --basedir)
    shift
    BASEDIR=$1
    ;;
  -*)
    echo 1>&2 "$progname: unrecognized option \`$1'"
    usage 1
    ;;
  *=*) CHAINS+=( "$1" ) ;;
  *:*) LINKS+=( "$1" ) ;;
  *)
    generate_id "$1"
    CHAINS+=( "$id=$1" )
    ;;
  esac
  shift
done

BASEDIR=$(cd "$BASEDIR" && pwd)
DATA="$BASEDIR/data"

validate
show_plan

# Ensure user understands what will be deleted
echo
if [[ -d $BASEDIR ]]; then
  read -p "$progname: will delete $BASEDIR folder. Do you wish to continue? (y/n): " -n 1 -r
  echo
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      exit 1
  fi
  rm -rf "$BASEDIR"
fi

mkdir -p "$BASEDIR/config"


# Fail on error.
set -e

#####################
# Create $BASEDIR/run

run=$BASEDIR/run
echo "creating $run"
cat <<\EOF >"$run"
#! /bin/bash
# run - create all the chains
# DO NOT EDIT - Automatically generated by $progname $args

cd $(dirname -- ${BASH_SOURCE[0]}) || exit $?
BASEDIR=$PWD
DATA="$BASEDIR/data"
trap 'kill $(jobs -p) 2>/dev/null' EXIT 

# Ensure gopath is set and go is installed
GOBIN=${GOBIN-${GOPATH-$HOME/go}/bin}
if [[ ! -d $GOPATH ]] || [[ ! -d $GOBIN ]] || [[ ! -x "$(which go)" ]]; then
  echo "Your \$GOPATH is not set or go is not installed,"
  echo "ensure you have a working installation of go before trying again..."
  echo "https://golang.org/doc/install"
  exit 1
fi

# Ensure user understands what will be deleted
if [[ -d $DATA && $1 != skip ]]; then
  read -p "$0 will delete $DATA folder. Do you wish to continue? (y/N): " -n 1 -r
  echo 
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      exit 1
  fi
fi
rm -rf "$DATA"

echo "mkdir $DATA"
mkdir -p "$DATA"

set -e

echo "Generating chain configurations..."
cd "$DATA"
EOF

if [[ "$(uname)" == Darwin ]]; then
  sedi="sed -i ''"
else
  sedi="sed -i"
fi

base=0
for i in ${!IDS[@]}; do
  ID=${IDS[$i]}
  json=${JSONS[$i]}
  DAEMON=$(eval echo $(jq .daemon $json))
  CLI=$(eval echo $(jq .cli $json))

  cat >>"$run" <<EOF
chainid="$ID"
DAEMON="$DAEMON"
CLI="$CLI"
p26656=$(( 26656 - $i * 100 ))
p26657=$(( 26657 - $i * 100 ))
p26658=$(( 26658 - $i * 100 ))
p6060=$(( 6060 + $i ))
EOF

  sed -e "s/sed -i/$sedi/g" >>"$run" <<\EOF

echo -e "\n" | $DAEMON testnet -o $chainid --v 1 --chain-id $chainid --node-dir-prefix n --keyring-backend test &> /dev/null

cfgpth="$DATA/$chainid/n0/$DAEMON/config/config.toml"
# TODO: Just index *some* specified tags, not all
sed -i 's/index_all_keys = false/index_all_keys = true/g' "$cfgpth"

# Set proper defaults and change ports
sed -i 's/"leveldb"/"goleveldb"/g' "$cfgpth"
sed -i "s#\"tcp://0.0.0.0:26656\"#\"tcp://0.0.0.0:$p26656\"#g" "$cfgpth"
sed -i "s#\"tcp://0.0.0.0:26657\"#\"tcp://0.0.0.0:$p26657\"#g" "$cfgpth"
sed -i "s#\"localhost:6060\"#\"localhost:$p6060\"#g" "$cfgpth"
sed -i "s#\"tcp://127.0.0.1:26658\"#\"tcp://127.0.0.1:$p26558\"#g" "$cfgpth"

# Make blocks run faster than normal
sed -i 's/timeout_commit = "[0-9]*s"/timeout_commit = "1s"/g' "$cfgpth"
sed -i 's/timeout_propose = "[0-9]*s"/timeout_propose = "1s"/g' "$cfgpth"

gclpth="$DATA/$chainid/n0/$CLI/"
$CLI config --home "$gclpth" chain-id $chainid &> /dev/null
$CLI config --home "$gclpth" output json &> /dev/null
$CLI config --home "$gclpth" node http://localhost:$p26657 &> /dev/null
EOF
done

for i in ${!IDS[@]}; do
  json=${JSONS[$i]}
  DAEMON=$(jq .daemon $json)
  ID=${IDS[$i]}
  chainid=$ID
  cat >>"$run" <<EOF

echo "'$DAEMON start ($ID) logs in $DATA/$ID.log"
$DAEMON --home "$DATA/$chainid/n0/$DAEMON" start --pruning=nothing > $chainid.log 2>&1 &
EOF
done

cat >>"$run" <<\EOF

echo "Ctrl-C exits, or you can background this script..."
wait
EOF
chmod +x "$run"

for i in ${!IDS[@]}; do
  id=${IDS[$i]}
  json=${JSONS[$i]}
  p26657=$(( 26657 - $i * 100 ))
  out="$BASEDIR/config/$id.json"
  echo "creating $out"
  jq ".link + { \"chain-id\": \"$id\", \"rpc-addr\": \"http://localhost:$p26657\", \"key\": \"testkey\" }" "$json" \
    > "$out"
done

for i in ${!SRCS[@]}; do
  src=${SRCS[$i]}
  get_port "$src"
  srcport=$port
  get_alpha "$src"
  srca=$ida

  dst=${DSTS[$i]}
  get_port "$dst"
  dstport=$port
  get_alpha "$dst"
  dsta=$ida

  demo="$srca$dsta"
  out="$BASEDIR/config/$demo.json"
  echo "creating $out"
  cat >"$out" <<EOF
{
  "src": {
    "chain-id": "$src",
    "client-id": "${dsta}client",
    "connection-id": "${dsta}link",
    "channel-id": "${dsta}xfer",
    "port-id": "$dstport"
  },
  "dst": {
    "chain-id": "$dst",
    "client-id": "${srca}client",
    "connection-id": "${srca}link",
    "channel-id": "${srca}xfer",
    "port-id": "$srcport"
  },
  "strategy": {
    "type": "naive"
  }
}
EOF
done

######################
# Create $BASEDIR/link

link=$BASEDIR/link
echo "creating $link"
cat <<\EOF >"$link"
#/bin/bash
# link - create specific relayers
# DO NOT EDIT - Automatically generated by $progname $args

cd $(dirname -- ${BASH_SOURCE[0]}) || exit $?
BASEDIR=$PWD
DATA="$BASEDIR/data"
RELAYER_CONF="$HOME/.relayer"
EOF

cat >>"$link" <<EOF
RELAYER_DIR="$RELAYER_DIR"
EOF

cat >>"$link" <<\EOF

set -e
trap 'kill $(jobs -p) 2>/dev/null' EXIT 

# Ensure jq is installed
if [[ ! -x "$(which jq)" ]]; then
  echo "jq (a tool for parsing json in the command line) is required..."
  echo "https://stedolan.github.io/jq/download/"
  exit 1
fi

# Ensure user understands what will be deleted
if [[ -d $RELAYER_CONF ]] && [[ "$1" != "skip" ]]; then
  read -p "$0 will delete $RELAYER_CONF folder. Do you wish to continue? (y/n): " -n 1 -r
  echo
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
      exit 1
  fi
fi

(
  cd "$RELAYER_DIR"
  rm -rf "$RELAYER_CONF"

  echo "Building Relayer..."
  make install
)

echo "Generating rly configurations..."
rly config init
rly config add-dir "$BASEDIR/config/"
EOF

for i in ${!IDS[@]}; do
  id=${IDS[$i]}
  json=${JSONS[$i]}
  CLI=$(eval echo $(jq .cli $json))
  DAEMON=$(eval echo $(jq .daemon $json))
  cat >>"$link" <<EOF

chainid="$id"
CLI="$CLI"
DAEMON="$DAEMON"
EOF
  cat >>"$link" <<\EOF
SEED=$(jq -r '.secret' "$DATA/$chainid/n0/$CLI/key_seed.json")
echo "Key $(rly keys restore $chainid testkey "$SEED") imported from $chainid to relayer..."
echo "Creating lite client for $chainid ($DAEMON)..."
(
  try=0
  gen="$DATA/$chainid/n0/$DAEMON/config/genesis.json"
  while [[ ! -f $gen ]]; do
    try=$(( $try + 1 ))
    echo "no $gen"
    echo "$chainid is not yet ready (try=$try)"
    sleep 1
  done
  rly lite init $chainid -f
) &
EOF
done

for i in ${!SRCS[@]}; do
  src=${SRCS[$i]}
  get_alpha "$src"
  srca=$ida

  dst=${DSTS[$i]}
  get_alpha "$dst"
  dsta=$ida

  demo="$srca$dsta"
  cat >>"$link" <<EOF

# Let all our chains initialise.
wait

echo "Starting 'rly tx link $demo' ($src<>$dst) logs in $DATA/$demo.log"
rly tx link $demo --timeout=3s -d 2>&1 > $DATA/$demo.log &
EOF
done

cat >>"$link" <<EOF

echo "Check the state of the links using 'rly paths list' to see when they are ready..."
(while sleep 5; do rly paths list; done) &

echo "Ctrl-C exits, or you can background this job..."
wait
EOF
chmod +x "$link"

#####################
cat <<EOF

=====================
Done generating $BASEDIR

You can use:
  $run
or:
  $link
at any time.

EOF

read -p "Do you wish to start the chains and relayers (y/N)? " -n 1 -r
echo

if [[ ! $REPLY =~ ^[Yy]$ ]]; then
  exit 0
fi

echo "Running $run"
"$run" skip &
sleep 10
echo "Running $link"
"$link" skip &
echo "Hit Control-C to exit"
wait
